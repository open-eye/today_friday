### 深入理解Java虚拟机

#### 第一部分 自动内存管理机制

![image-20210217102331152](C:\Users\THINK\Documents\MyFiles\myBlog\mdFiles\深入理解Java虚拟机.assets\image-20210217102331152.png)

#### 1. 运行时数据区域

---

**程序计数器：**当前线程所执行的字节码的行号指示器。记录下一条需要执行的字节码指令，如分支、循环、跳转、异常处理、线程恢复等。各线程之间计数器互不影响，独立存储。如果执行 Java 方法，计数器记录正在执行的虚拟机字节码指令的地址；如果执行 Native 方法，计数器值为空 (Undefined)。此内存区域是唯一一个在虚拟机规范中没有规定任何   OutOfMemoryError  情况的区域。



**Java 虚拟机栈：**每个方法在执行的同时都会创建一个栈帧用于存储*局部变量表* 、操作数帧、动态链接、*方法出口* 等信息。每一个方法从调用直至执行完成的过程， 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。局部变量表存放了编译期可知 (所需内存在编译期分配好) 的各种基本数据类型 、 对象引用 (reference类型， 它不等同于对象本身， 可能是一个指向对象起始地址的引用指针， 也可能是指向一个代表对象的句柄或其他与此对象相关的位置) 和 returnAddress 类型 (指向了一条字节码指令的地址) 。会抛出 StackOverflowError OutOfMemoryError 异常。



**本地方法栈：**与虚拟机栈非常相似，区别于本地方法栈为虚拟机使用到的 Native 方法服务。会抛出 StackOverflowError OutOfMemoryError 异常。



**Java 堆：**内存最大一块，一般所有的对象实例都要在堆上分配。也称 “GC堆” ，  从内存回收的角度来看， 由于现在收集器基本都采用分代收集算法， 所以 Java 堆中还可以细分为： 新生代和老年代； 再细致一点的有Eden空间、 From Survivor空间、 To Survivor空间等。**存储的都是对象实例，划分区域是为了更好的回收。**



**方法区：**用于存储已被虚拟机加载的类信息、 常量、 静态变量、 即时编译器编译后的代码等数据。也称为 **“永久代”** 垃圾收集行为比较少出现。



**运行时常量池：**方法区的一部分。Class 文件中除了有类的版本、 字段、 方法、 接口等描述信息外，还有一项信息是常量池，用于存放**编译期生成**的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。  运行期间也可能将新的常量放入池中， String 类的 intern() 方法。



**直接内存：**  本机内存，在 JDK 1.4中新加入了NIO（ New Input/Output） 类， 引入了一种基于通道（ Channel） 与缓冲区（ Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据。

---

#### 2.3 HotSpot 虚拟机对象探秘

---

**对象的创建：**遇到 new 指令时，检查该指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。



